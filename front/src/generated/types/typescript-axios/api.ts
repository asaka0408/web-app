/* tslint:disable */
/* eslint-disable */
/**
 * Saikan-Shoin API
 * API for Saikan-Shoin.
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * ユーザーが本登録済みかどうか
 * @export
 * @interface CompletedSignUp
 */
export interface CompletedSignUp {
  /**
   *
   * @type {boolean}
   * @memberof CompletedSignUp
   */
  completed_sign_up?: boolean;
}
/**
 *
 * @export
 * @interface CreateHandbook
 */
export interface CreateHandbook {
  /**
   *
   * @type {number}
   * @memberof CreateHandbook
   */
  year?: number;
  /**
   *
   * @type {number}
   * @memberof CreateHandbook
   */
  month?: number;
  /**
   *
   * @type {number}
   * @memberof CreateHandbook
   */
  font_id?: number;
  /**
   *
   * @type {number}
   * @memberof CreateHandbook
   */
  grade_id?: number;
  /**
   *
   * @type {UpdateHandbookDemonstration}
   * @memberof CreateHandbook
   */
  demonstration?: UpdateHandbookDemonstration;
  /**
   *
   * @type {UpdateHandbookExplanation}
   * @memberof CreateHandbook
   */
  explanation?: UpdateHandbookExplanation;
}
/**
 *
 * @export
 * @interface Font
 */
export interface Font {
  /**
   *
   * @type {FontFont}
   * @memberof Font
   */
  font?: FontFont;
}
/**
 *
 * @export
 * @interface FontFont
 */
export interface FontFont {
  /**
   *
   * @type {number}
   * @memberof FontFont
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof FontFont
   */
  name?: string;
}
/**
 *
 * @export
 * @interface FontsInner
 */
export interface FontsInner {
  /**
   *
   * @type {number}
   * @memberof FontsInner
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof FontsInner
   */
  font_name?: string;
  /**
   *
   * @type {number}
   * @memberof FontsInner
   */
  course_type?: number;
}
/**
 *
 * @export
 * @interface Handbook
 */
export interface Handbook {
  /**
   *
   * @type {number}
   * @memberof Handbook
   */
  id?: number;
  /**
   *
   * @type {number}
   * @memberof Handbook
   */
  year?: number;
  /**
   *
   * @type {number}
   * @memberof Handbook
   */
  month?: number;
  /**
   *
   * @type {number}
   * @memberof Handbook
   */
  grade_id?: number;
  /**
   *
   * @type {UpdateHandbookDemonstration}
   * @memberof Handbook
   */
  demonstration?: UpdateHandbookDemonstration;
  /**
   *
   * @type {UpdateHandbookExplanation}
   * @memberof Handbook
   */
  explanation?: UpdateHandbookExplanation;
  /**
   *
   * @type {FontFont}
   * @memberof Handbook
   */
  font?: FontFont;
}
/**
 *
 * @export
 * @interface HandbooksAvailTermsInner
 */
export interface HandbooksAvailTermsInner {
  /**
   *
   * @type {number}
   * @memberof HandbooksAvailTermsInner
   */
  year?: number;
  /**
   *
   * @type {number}
   * @memberof HandbooksAvailTermsInner
   */
  month?: number;
}
/**
 *
 * @export
 * @interface HandbooksInner
 */
export interface HandbooksInner {
  /**
   *
   * @type {number}
   * @memberof HandbooksInner
   */
  id?: number;
  /**
   *
   * @type {number}
   * @memberof HandbooksInner
   */
  year?: number;
  /**
   *
   * @type {number}
   * @memberof HandbooksInner
   */
  month?: number;
  /**
   *
   * @type {number}
   * @memberof HandbooksInner
   */
  font_id?: number;
  /**
   *
   * @type {number}
   * @memberof HandbooksInner
   */
  grade_id?: number;
}
/**
 *
 * @export
 * @interface ModelError
 */
export interface ModelError {
  /**
   *
   * @type {number}
   * @memberof ModelError
   */
  code: number;
  /**
   *
   * @type {string}
   * @memberof ModelError
   */
  message: string;
}
/**
 *
 * @export
 * @interface UpdateHandbook
 */
export interface UpdateHandbook {
  /**
   *
   * @type {UpdateHandbookDemonstration}
   * @memberof UpdateHandbook
   */
  demonstration?: UpdateHandbookDemonstration;
  /**
   *
   * @type {UpdateHandbookExplanation}
   * @memberof UpdateHandbook
   */
  explanation?: UpdateHandbookExplanation;
}
/**
 *
 * @export
 * @interface UpdateHandbookDemonstration
 */
export interface UpdateHandbookDemonstration {
  /**
   *
   * @type {Array<string>}
   * @memberof UpdateHandbookDemonstration
   */
  videos?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof UpdateHandbookDemonstration
   */
  images?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof UpdateHandbookDemonstration
   */
  comment?: string;
}
/**
 *
 * @export
 * @interface UpdateHandbookExplanation
 */
export interface UpdateHandbookExplanation {
  /**
   *
   * @type {Array<string>}
   * @memberof UpdateHandbookExplanation
   */
  videos?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof UpdateHandbookExplanation
   */
  images?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof UpdateHandbookExplanation
   */
  comment?: string;
}
/**
 * 更新する際にリクエストに含めるユーザー情報
 * @export
 * @interface UpdateUser
 */
export interface UpdateUser {
  /**
   *
   * @type {Array<UserBaseRolesInner>}
   * @memberof UpdateUser
   */
  roles?: Array<UserBaseRolesInner>;
  /**
   *
   * @type {string}
   * @memberof UpdateUser
   */
  last_name: string;
  /**
   *
   * @type {string}
   * @memberof UpdateUser
   */
  first_name: string;
  /**
   *
   * @type {string}
   * @memberof UpdateUser
   */
  nickname: string;
  /**
   *
   * @type {number}
   * @memberof UpdateUser
   */
  course_type: number;
  /**
   *
   * @type {string}
   * @memberof UpdateUser
   */
  email: string;
  /**
   *
   * @type {number}
   * @memberof UpdateUser
   */
  gender_id: number;
  /**
   *
   * @type {string}
   * @memberof UpdateUser
   */
  birthday: string;
  /**
   *
   * @type {string}
   * @memberof UpdateUser
   */
  prefecture: string;
  /**
   *
   * @type {boolean}
   * @memberof UpdateUser
   */
  is_experienced: boolean;
  /**
   *
   * @type {string}
   * @memberof UpdateUser
   */
  parent_last_name?: string;
  /**
   *
   * @type {string}
   * @memberof UpdateUser
   */
  parent_first_name?: string;
  /**
   *
   * @type {boolean}
   * @memberof UpdateUser
   */
  completed_sign_up?: boolean;
}
/**
 *
 * @export
 * @interface UploadImage201Response
 */
export interface UploadImage201Response {
  /**
   *
   * @type {number}
   * @memberof UploadImage201Response
   */
  image_url?: number;
}
/**
 *
 * @export
 * @interface UploadImageRequest
 */
export interface UploadImageRequest {
  /**
   *
   * @type {number}
   * @memberof UploadImageRequest
   */
  year?: number;
  /**
   *
   * @type {number}
   * @memberof UploadImageRequest
   */
  month?: number;
  /**
   *
   * @type {number}
   * @memberof UploadImageRequest
   */
  gradeId?: number | null;
  /**
   *
   * @type {number}
   * @memberof UploadImageRequest
   */
  fontId?: number;
  /**
   *
   * @type {boolean}
   * @memberof UploadImageRequest
   */
  is_demonstration?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof UploadImageRequest
   */
  is_explanation?: boolean;
  /**
   *
   * @type {File}
   * @memberof UploadImageRequest
   */
  image_file?: File;
}
/**
 *
 * @export
 * @interface UploadVideo201Response
 */
export interface UploadVideo201Response {
  /**
   *
   * @type {number}
   * @memberof UploadVideo201Response
   */
  video_id?: number;
}
/**
 *
 * @export
 * @interface UploadVideoRequest
 */
export interface UploadVideoRequest {
  /**
   *
   * @type {string}
   * @memberof UploadVideoRequest
   */
  file_name?: string;
  /**
   *
   * @type {File}
   * @memberof UploadVideoRequest
   */
  video_file?: File;
}
/**
 * レスポンスで返すユーザー情報
 * @export
 * @interface User
 */
export interface User {
  /**
   *
   * @type {Array<UserBaseRolesInner>}
   * @memberof User
   */
  roles?: Array<UserBaseRolesInner>;
  /**
   *
   * @type {string}
   * @memberof User
   */
  last_name: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  first_name: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  nickname: string;
  /**
   *
   * @type {number}
   * @memberof User
   */
  course_type: number;
  /**
   *
   * @type {string}
   * @memberof User
   */
  email: string;
  /**
   *
   * @type {number}
   * @memberof User
   */
  gender_id: number;
  /**
   *
   * @type {string}
   * @memberof User
   */
  birthday: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  prefecture: string;
  /**
   *
   * @type {boolean}
   * @memberof User
   */
  is_experienced: boolean;
  /**
   *
   * @type {string}
   * @memberof User
   */
  parent_last_name?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  parent_first_name?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  id: string;
}
/**
 * ユーザー関連スキーマの共通部分
 * @export
 * @interface UserBase
 */
export interface UserBase {
  /**
   *
   * @type {Array<UserBaseRolesInner>}
   * @memberof UserBase
   */
  roles?: Array<UserBaseRolesInner>;
  /**
   *
   * @type {string}
   * @memberof UserBase
   */
  last_name: string;
  /**
   *
   * @type {string}
   * @memberof UserBase
   */
  first_name: string;
  /**
   *
   * @type {string}
   * @memberof UserBase
   */
  nickname: string;
  /**
   *
   * @type {number}
   * @memberof UserBase
   */
  course_type: number;
  /**
   *
   * @type {string}
   * @memberof UserBase
   */
  email: string;
  /**
   *
   * @type {number}
   * @memberof UserBase
   */
  gender_id: number;
  /**
   *
   * @type {string}
   * @memberof UserBase
   */
  birthday: string;
  /**
   *
   * @type {string}
   * @memberof UserBase
   */
  prefecture: string;
  /**
   *
   * @type {boolean}
   * @memberof UserBase
   */
  is_experienced: boolean;
  /**
   *
   * @type {string}
   * @memberof UserBase
   */
  parent_last_name?: string;
  /**
   *
   * @type {string}
   * @memberof UserBase
   */
  parent_first_name?: string;
}
/**
 *
 * @export
 * @interface UserBaseRolesInner
 */
export interface UserBaseRolesInner {
  /**
   *
   * @type {string}
   * @memberof UserBaseRolesInner
   */
  role_name?: string;
  /**
   *
   * @type {string}
   * @memberof UserBaseRolesInner
   */
  display_name?: string;
}
/**
 * ユーザーのUUID
 * @export
 * @interface UserId
 */
export interface UserId {
  /**
   *
   * @type {string}
   * @memberof UserId
   */
  id?: string;
}
/**
 * ログインユーザーの情報
 * @export
 * @interface Userinfo
 */
export interface Userinfo {
  /**
   *
   * @type {Array<UserBaseRolesInner>}
   * @memberof Userinfo
   */
  roles?: Array<UserBaseRolesInner>;
  /**
   *
   * @type {string}
   * @memberof Userinfo
   */
  last_name: string;
  /**
   *
   * @type {string}
   * @memberof Userinfo
   */
  first_name: string;
  /**
   *
   * @type {string}
   * @memberof Userinfo
   */
  nickname: string;
  /**
   *
   * @type {number}
   * @memberof Userinfo
   */
  course_type: number;
  /**
   *
   * @type {string}
   * @memberof Userinfo
   */
  email: string;
  /**
   *
   * @type {number}
   * @memberof Userinfo
   */
  gender_id: number;
  /**
   *
   * @type {string}
   * @memberof Userinfo
   */
  birthday: string;
  /**
   *
   * @type {string}
   * @memberof Userinfo
   */
  prefecture: string;
  /**
   *
   * @type {boolean}
   * @memberof Userinfo
   */
  is_experienced: boolean;
  /**
   *
   * @type {string}
   * @memberof Userinfo
   */
  parent_last_name?: string;
  /**
   *
   * @type {string}
   * @memberof Userinfo
   */
  parent_first_name?: string;
  /**
   *
   * @type {string}
   * @memberof Userinfo
   */
  id: string;
  /**
   *
   * @type {boolean}
   * @memberof Userinfo
   */
  completed_sign_up: boolean;
}

/**
 * FontApi - axios parameter creator
 * @export
 */
export const FontApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * 書体情報全件取得 コースを指定するとそのコースに対応した書体を全件取得
     * @param {number} [courseType] コースID(一般/1 学生/2)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFonts: async (
      courseType?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/fonts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (courseType !== undefined) {
        localVarQueryParameter['course_type'] = courseType;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * FontApi - functional programming interface
 * @export
 */
export const FontApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = FontApiAxiosParamCreator(configuration);
  return {
    /**
     * 書体情報全件取得 コースを指定するとそのコースに対応した書体を全件取得
     * @param {number} [courseType] コースID(一般/1 学生/2)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFonts(
      courseType?: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FontsInner>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getFonts(courseType, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * FontApi - factory interface
 * @export
 */
export const FontApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = FontApiFp(configuration);
  return {
    /**
     * 書体情報全件取得 コースを指定するとそのコースに対応した書体を全件取得
     * @param {number} [courseType] コースID(一般/1 学生/2)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFonts(courseType?: number, options?: any): AxiosPromise<Array<FontsInner>> {
      return localVarFp.getFonts(courseType, options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * FontApi - object-oriented interface
 * @export
 * @class FontApi
 * @extends {BaseAPI}
 */
export class FontApi extends BaseAPI {
  /**
   * 書体情報全件取得 コースを指定するとそのコースに対応した書体を全件取得
   * @param {number} [courseType] コースID(一般/1 学生/2)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FontApi
   */
  public getFonts(courseType?: number, options?: AxiosRequestConfig) {
    return FontApiFp(this.configuration)
      .getFonts(courseType, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * HandBookApi - axios parameter creator
 * @export
 */
export const HandBookApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * 手本情報追加
     * @param {CreateHandbook} createHandbook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createHandbook: async (
      createHandbook: CreateHandbook,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'createHandbook' is not null or undefined
      assertParamExists('createHandbook', 'createHandbook', createHandbook);
      const localVarPath = `/handbooks`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createHandbook,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 手本情報取得
     * @param {number} id 手本情報更新で手本を識別するID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getHandbook: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getHandbook', 'id', id);
      const localVarPath = `/handbooks/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 年月と書体と学年を指定すると対応する手本情報を取得
     * @param {number} [year] 年を指定する
     * @param {number} [month] 月を指定する
     * @param {number} [fontId] 書体ID
     * @param {number} [gradeId] 学年ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getHandbooks: async (
      year?: number,
      month?: number,
      fontId?: number,
      gradeId?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/handbooks`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (year !== undefined) {
        localVarQueryParameter['year'] = year;
      }

      if (month !== undefined) {
        localVarQueryParameter['month'] = month;
      }

      if (fontId !== undefined) {
        localVarQueryParameter['font_id'] = fontId;
      }

      if (gradeId !== undefined) {
        localVarQueryParameter['grade_id'] = gradeId;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 手本情報が存在する、年と月の情報を取得
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getHandbooksAvailTerms: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/handbooks/avail-terms`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 手本情報更新
     * @param {number} id 手本情報更新で手本を識別するID
     * @param {UpdateHandbook} updateHandbook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateHandbook: async (
      id: number,
      updateHandbook: UpdateHandbook,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('updateHandbook', 'id', id);
      // verify required parameter 'updateHandbook' is not null or undefined
      assertParamExists('updateHandbook', 'updateHandbook', updateHandbook);
      const localVarPath = `/handbooks/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateHandbook,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * HandBookApi - functional programming interface
 * @export
 */
export const HandBookApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = HandBookApiAxiosParamCreator(configuration);
  return {
    /**
     * 手本情報追加
     * @param {CreateHandbook} createHandbook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createHandbook(
      createHandbook: CreateHandbook,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createHandbook(
        createHandbook,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * 手本情報取得
     * @param {number} id 手本情報更新で手本を識別するID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getHandbook(
      id: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Handbook>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getHandbook(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * 年月と書体と学年を指定すると対応する手本情報を取得
     * @param {number} [year] 年を指定する
     * @param {number} [month] 月を指定する
     * @param {number} [fontId] 書体ID
     * @param {number} [gradeId] 学年ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getHandbooks(
      year?: number,
      month?: number,
      fontId?: number,
      gradeId?: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<HandbooksInner>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getHandbooks(
        year,
        month,
        fontId,
        gradeId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * 手本情報が存在する、年と月の情報を取得
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getHandbooksAvailTerms(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<HandbooksAvailTermsInner>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getHandbooksAvailTerms(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * 手本情報更新
     * @param {number} id 手本情報更新で手本を識別するID
     * @param {UpdateHandbook} updateHandbook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateHandbook(
      id: number,
      updateHandbook: UpdateHandbook,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Handbook>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateHandbook(
        id,
        updateHandbook,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * HandBookApi - factory interface
 * @export
 */
export const HandBookApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = HandBookApiFp(configuration);
  return {
    /**
     * 手本情報追加
     * @param {CreateHandbook} createHandbook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createHandbook(createHandbook: CreateHandbook, options?: any): AxiosPromise<void> {
      return localVarFp
        .createHandbook(createHandbook, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 手本情報取得
     * @param {number} id 手本情報更新で手本を識別するID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getHandbook(id: number, options?: any): AxiosPromise<Handbook> {
      return localVarFp.getHandbook(id, options).then((request) => request(axios, basePath));
    },
    /**
     * 年月と書体と学年を指定すると対応する手本情報を取得
     * @param {number} [year] 年を指定する
     * @param {number} [month] 月を指定する
     * @param {number} [fontId] 書体ID
     * @param {number} [gradeId] 学年ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getHandbooks(
      year?: number,
      month?: number,
      fontId?: number,
      gradeId?: number,
      options?: any
    ): AxiosPromise<Array<HandbooksInner>> {
      return localVarFp
        .getHandbooks(year, month, fontId, gradeId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 手本情報が存在する、年と月の情報を取得
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getHandbooksAvailTerms(options?: any): AxiosPromise<Array<HandbooksAvailTermsInner>> {
      return localVarFp.getHandbooksAvailTerms(options).then((request) => request(axios, basePath));
    },
    /**
     * 手本情報更新
     * @param {number} id 手本情報更新で手本を識別するID
     * @param {UpdateHandbook} updateHandbook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateHandbook(
      id: number,
      updateHandbook: UpdateHandbook,
      options?: any
    ): AxiosPromise<Handbook> {
      return localVarFp
        .updateHandbook(id, updateHandbook, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * HandBookApi - object-oriented interface
 * @export
 * @class HandBookApi
 * @extends {BaseAPI}
 */
export class HandBookApi extends BaseAPI {
  /**
   * 手本情報追加
   * @param {CreateHandbook} createHandbook
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HandBookApi
   */
  public createHandbook(createHandbook: CreateHandbook, options?: AxiosRequestConfig) {
    return HandBookApiFp(this.configuration)
      .createHandbook(createHandbook, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 手本情報取得
   * @param {number} id 手本情報更新で手本を識別するID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HandBookApi
   */
  public getHandbook(id: number, options?: AxiosRequestConfig) {
    return HandBookApiFp(this.configuration)
      .getHandbook(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 年月と書体と学年を指定すると対応する手本情報を取得
   * @param {number} [year] 年を指定する
   * @param {number} [month] 月を指定する
   * @param {number} [fontId] 書体ID
   * @param {number} [gradeId] 学年ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HandBookApi
   */
  public getHandbooks(
    year?: number,
    month?: number,
    fontId?: number,
    gradeId?: number,
    options?: AxiosRequestConfig
  ) {
    return HandBookApiFp(this.configuration)
      .getHandbooks(year, month, fontId, gradeId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 手本情報が存在する、年と月の情報を取得
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HandBookApi
   */
  public getHandbooksAvailTerms(options?: AxiosRequestConfig) {
    return HandBookApiFp(this.configuration)
      .getHandbooksAvailTerms(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 手本情報更新
   * @param {number} id 手本情報更新で手本を識別するID
   * @param {UpdateHandbook} updateHandbook
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HandBookApi
   */
  public updateHandbook(id: number, updateHandbook: UpdateHandbook, options?: AxiosRequestConfig) {
    return HandBookApiFp(this.configuration)
      .updateHandbook(id, updateHandbook, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ImageApi - axios parameter creator
 * @export
 */
export const ImageApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * 一般ユーザーの画像ファイルアップロード
     * @param {UploadImageRequest} uploadImageRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadImage: async (
      uploadImageRequest: UploadImageRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'uploadImageRequest' is not null or undefined
      assertParamExists('uploadImage', 'uploadImageRequest', uploadImageRequest);
      const localVarPath = `/image`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        uploadImageRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ImageApi - functional programming interface
 * @export
 */
export const ImageApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ImageApiAxiosParamCreator(configuration);
  return {
    /**
     * 一般ユーザーの画像ファイルアップロード
     * @param {UploadImageRequest} uploadImageRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async uploadImage(
      uploadImageRequest: UploadImageRequest,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadImage201Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.uploadImage(
        uploadImageRequest,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * ImageApi - factory interface
 * @export
 */
export const ImageApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ImageApiFp(configuration);
  return {
    /**
     * 一般ユーザーの画像ファイルアップロード
     * @param {UploadImageRequest} uploadImageRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadImage(
      uploadImageRequest: UploadImageRequest,
      options?: any
    ): AxiosPromise<UploadImage201Response> {
      return localVarFp
        .uploadImage(uploadImageRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ImageApi - object-oriented interface
 * @export
 * @class ImageApi
 * @extends {BaseAPI}
 */
export class ImageApi extends BaseAPI {
  /**
   * 一般ユーザーの画像ファイルアップロード
   * @param {UploadImageRequest} uploadImageRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ImageApi
   */
  public uploadImage(uploadImageRequest: UploadImageRequest, options?: AxiosRequestConfig) {
    return ImageApiFp(this.configuration)
      .uploadImage(uploadImageRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * UserInfoApi - axios parameter creator
 * @export
 */
export const UserInfoApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * 自分のユーザー情報取得
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLoginUser: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/userinfo`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UserInfoApi - functional programming interface
 * @export
 */
export const UserInfoApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UserInfoApiAxiosParamCreator(configuration);
  return {
    /**
     * 自分のユーザー情報取得
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLoginUser(
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Userinfo>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getLoginUser(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * UserInfoApi - factory interface
 * @export
 */
export const UserInfoApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = UserInfoApiFp(configuration);
  return {
    /**
     * 自分のユーザー情報取得
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLoginUser(options?: any): AxiosPromise<Userinfo> {
      return localVarFp.getLoginUser(options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * UserInfoApi - object-oriented interface
 * @export
 * @class UserInfoApi
 * @extends {BaseAPI}
 */
export class UserInfoApi extends BaseAPI {
  /**
   * 自分のユーザー情報取得
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserInfoApi
   */
  public getLoginUser(options?: AxiosRequestConfig) {
    return UserInfoApiFp(this.configuration)
      .getLoginUser(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * ユーザー情報1件取得
     * @param {string} id ユーザーを識別するID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUser: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getUser', 'id', id);
      const localVarPath = `/users/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 全ユーザー情報取得
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsers: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * ユーザー情報1件更新
     * @param {string} id ユーザーを識別するID
     * @param {UpdateUser} updateUser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUser: async (
      id: string,
      updateUser: UpdateUser,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('updateUser', 'id', id);
      // verify required parameter 'updateUser' is not null or undefined
      assertParamExists('updateUser', 'updateUser', updateUser);
      const localVarPath = `/users/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateUser,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration);
  return {
    /**
     * ユーザー情報1件取得
     * @param {string} id ユーザーを識別するID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUser(
      id: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * 全ユーザー情報取得
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUsers(
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * ユーザー情報1件更新
     * @param {string} id ユーザーを識別するID
     * @param {UpdateUser} updateUser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateUser(
      id: string,
      updateUser: UpdateUser,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(id, updateUser, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = UsersApiFp(configuration);
  return {
    /**
     * ユーザー情報1件取得
     * @param {string} id ユーザーを識別するID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUser(id: string, options?: any): AxiosPromise<User> {
      return localVarFp.getUser(id, options).then((request) => request(axios, basePath));
    },
    /**
     * 全ユーザー情報取得
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsers(options?: any): AxiosPromise<Array<User>> {
      return localVarFp.getUsers(options).then((request) => request(axios, basePath));
    },
    /**
     * ユーザー情報1件更新
     * @param {string} id ユーザーを識別するID
     * @param {UpdateUser} updateUser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUser(id: string, updateUser: UpdateUser, options?: any): AxiosPromise<User> {
      return localVarFp
        .updateUser(id, updateUser, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
  /**
   * ユーザー情報1件取得
   * @param {string} id ユーザーを識別するID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public getUser(id: string, options?: AxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .getUser(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 全ユーザー情報取得
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public getUsers(options?: AxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .getUsers(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * ユーザー情報1件更新
   * @param {string} id ユーザーを識別するID
   * @param {UpdateUser} updateUser
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public updateUser(id: string, updateUser: UpdateUser, options?: AxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .updateUser(id, updateUser, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * VideoApi - axios parameter creator
 * @export
 */
export const VideoApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * 動画ファイルアップロード
     * @param {UploadVideoRequest} uploadVideoRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadVideo: async (
      uploadVideoRequest: UploadVideoRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'uploadVideoRequest' is not null or undefined
      assertParamExists('uploadVideo', 'uploadVideoRequest', uploadVideoRequest);
      const localVarPath = `/video`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        uploadVideoRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * VideoApi - functional programming interface
 * @export
 */
export const VideoApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = VideoApiAxiosParamCreator(configuration);
  return {
    /**
     * 動画ファイルアップロード
     * @param {UploadVideoRequest} uploadVideoRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async uploadVideo(
      uploadVideoRequest: UploadVideoRequest,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadVideo201Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.uploadVideo(
        uploadVideoRequest,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * VideoApi - factory interface
 * @export
 */
export const VideoApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = VideoApiFp(configuration);
  return {
    /**
     * 動画ファイルアップロード
     * @param {UploadVideoRequest} uploadVideoRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadVideo(
      uploadVideoRequest: UploadVideoRequest,
      options?: any
    ): AxiosPromise<UploadVideo201Response> {
      return localVarFp
        .uploadVideo(uploadVideoRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * VideoApi - object-oriented interface
 * @export
 * @class VideoApi
 * @extends {BaseAPI}
 */
export class VideoApi extends BaseAPI {
  /**
   * 動画ファイルアップロード
   * @param {UploadVideoRequest} uploadVideoRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VideoApi
   */
  public uploadVideo(uploadVideoRequest: UploadVideoRequest, options?: AxiosRequestConfig) {
    return VideoApiFp(this.configuration)
      .uploadVideo(uploadVideoRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
